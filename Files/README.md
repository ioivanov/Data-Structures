## Файлови потоци
### Създаване на файлов поток и отваряне на файл
* Използваме библиотеката `fstream`
* `fstream myFileStream;` - създаване на файлов поток
* `myFileStream.open("myFile.txt");` - отваряне на файл
* `fstream myFileStream("myFile.txt")` - създава файлов поток и отваря файл (комбинира горните две точки)
* `ifstream fi("fileName")` - отваря файла за четене т.е. ще четем от този файл
* `ofstream fo("filename")` - отваря файла за писане т.е. ще пишем в този файл

Като втори аргумент при отварянето на файл се подават флагове, които определят в какъв режим да се отвори файла:
* `ios::in` - отваря файла за четене
* `ios::out` - отваря файла за писане
* `ios::binary` - операциите се изпълняват в двоичен режим вместо в текстов
* `ios::ate` - след отварянето на файла позицията за писане се поставя в края на файла
* `ios::app` - след всяка операция позицията за писане се поставя в края на файла
* `ios::trunc` - изтрива съдържанието на файла
* Комбинираме флаговете с побитово или: `ios::out | ios::trunc`

### Затваряне на файл
* `myFileStream.close()` - затваря файл. След като е затворен можем да използваме същата променлива за да отворим друг файл `myFileStream.open("textFile.txt", ios::out | ios::app)`
* Въпреки това, че компилатора се сърди повече за липсваща `;` отколкото за незатворен файлов поток е хубаво след като приключим работа с даден файл да го затворим

## Изход на поток
### Неформатиран изход:
* `ostream& put(char)` - вмъква символ в поток. Пример: `fo.put('A')`
* `ostream& write(const char*, streamsize)` - вмъква streamsize на брой символи от подадения символен низ в потока. Използваме тази функция при работа с двоични файлове. Пример: `fo.write(buff, 10)`
### Форматиран изход:
* `ostream& operator<<(ostream&, T)` - Пример: `fo<<buff`

## Вход от поток
### Неформатиран вход:
* `istream& get(char&)` - прочита един символ. Пример: `fi.get(c)`.
* `istream& get(char*,streamsize,char)` - прочита символи и ги записва в първия аргумент докато не се прочетът или `streamsize-1` на брой символи или не се намери третия аргумент. Пример: `fi.get(buff, 25, '\n')`. Забележка ако разделящият символ (третия аргумент) се срещне четенето спира но той не се извлича от потока т.е. при следващото четене първо той ще се прочете. 
* `istream& getline(char*,streamsize,char)` - работи като горната точка с разликата, че премахва разделящият символ от потока. Пример: `is.getline(buff, 25, '\n')`
* `streamsize gcount() const` - връща броя на извлечените символи от последната операция за неформатиран вход. Пример: `fi.gcount()`
* `istream& read(char*, streamsize)` - прочита `streamsize` на брой символи. Използваме тази функция при работа с двоични файлове. Пример: `fi.read(buff, 5)`
### Форматиран вход:
* `istream& operator>>(istream&, T&)` - Пример: `fi>>buff`

## Низови потоци
### Входен поток от низ: `istringstream`
Пример:
``` 
char s[] = "1 2 3";
istringstream iss(s);
int a, b, c;
iss >> a >> b >> c; 
```
### Изходен поток към низ: `ostringstream`
Пример:
```
ostringstream oss;
oss << 1.2 << ’ ’ << 3.4
cout << oss.str();
```

## Потокови манипулатори
* `iomanip` - името на библиотеката
* `stream << data1 << manipulator << data2` - примерен начин за използване
* Манипулатори за изход: `endl`, `ends`, `flush`
* Манипулатори за бройна система: `hex`, `oct`, `dec`
* Манипулатори за поле: `setw`, `setfill`, `left`, `right`, `internal`
* Манипулатори за дробни числа: `fixed`, `scientific`, `setprecision`
* Манипулатори за формат: `setiosflags`, `setbase`
* . . . и много други
[Прочетете за манипулаторите тук](http://www.cplusplus.com/reference/iomanip/)

## Пряк достъп до файлове
Селектори:
* `streampos tellg() const` - връща позицията на указателя за четене т.е. ако отворим файл и прочетем 6 символа ще върне 6, ако прочетем още 6 и извикаме пак функцията ще върне 12. Пример: `fi.tellg()`
* `streampos tellp() const` - връща позицията на указателя за писане. Пример: `fo.tellp()`
Мутатори:
* `istream& seekg(streampos, seekdir = beg)` - променя позицията на указателя за четене. Първият аргумент е цяло число (може и отрицателно) а вторият е позиция `ios::beg`, `ios::curr`, `ios::end` съответно за началото на файла, текущата позиция или края на файла. Пример: `seekg(42, ios::curr)` - премества укаателя за четене с 42 байта напред
* `ostream& seekp(streampos, seekdir = beg)` - променя позицията на указателя за писане. Пример: `seekp(-42, ios::end)` - поставя указателя за писане на 42 байта преди края на файла.

# Задача 1
Намерете броя на редовете на даден текстов файл.

# Задача 2
Изпишете съдържанието на даден дроичен файл на конзолата, под формата на байтове

# Задача 3
Заместете всяко срещане на даден символен низ във файл със звездички.

# Задача 4
За класа `Student` предефинирайте операторите за вход и изход.

# Задача 5
Реализирайте следните функции:
* `Student* readStudents(int& n)` - чете `n` на брой студенти от стандартния вход.
* `void writeStudents(Student* s, int n)` - записва студентите във файл.
* `void toMainBook()` - чете студентите от файл и записва в двоичен файл само тези, които имат оценка над 3.
* `void raiseGrade(int fn)`- увеличава оценката на студент с факултетен номер `fn`, използвайки двоичния файл от предишната точка.
